<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ray Tracer - C++ Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #fff;
            padding: 20px;
        }

        .container {
            text-align: center;
        }

        h1 {
            color: #f87171;
            margin-bottom: 10px;
        }

        .badge {
            background: linear-gradient(135deg, #f87171, #dc2626);
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.75rem;
            display: inline-block;
            margin-bottom: 20px;
        }

        canvas {
            border: 3px solid #333;
            border-radius: 10px;
            display: block;
            margin: 0 auto;
        }

        .controls {
            margin-top: 20px;
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .control-group {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px 20px;
            border-radius: 10px;
        }

        .control-group label {
            display: block;
            font-size: 0.85rem;
            color: #888;
            margin-bottom: 8px;
        }

        input[type="range"] {
            width: 120px;
        }

        input[type="color"] {
            width: 50px;
            height: 30px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        button {
            padding: 12px 30px;
            font-size: 1rem;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            transition: all 0.3s;
        }

        button:hover {
            transform: translateY(-2px);
        }

        .status {
            margin-top: 15px;
            color: #888;
            font-size: 0.9rem;
        }
    </style>
</head>

<body>
    <div class="container">
        <span class="badge">C++ Demo</span>
        <h1>üåü Ray Tracer</h1>
        <p style="color: #888; margin-bottom: 20px;">Real-time ray traced spheres with reflections</p>

        <canvas id="canvas" width="500" height="400"></canvas>

        <div class="controls">
            <div class="control-group">
                <label>Sphere 1 Color</label>
                <input type="color" id="sphere1Color" value="#ff6b6b" onchange="render()">
            </div>
            <div class="control-group">
                <label>Sphere 2 Color</label>
                <input type="color" id="sphere2Color" value="#4ecdc4" onchange="render()">
            </div>
            <div class="control-group">
                <label>Light X Position</label>
                <input type="range" id="lightX" min="-3" max="3" step="0.1" value="2" onchange="render()">
            </div>
            <div class="control-group">
                <label>Reflection</label>
                <input type="range" id="reflection" min="0" max="1" step="0.1" value="0.3" onchange="render()">
            </div>
        </div>

        <div style="margin-top: 20px;">
            <button onclick="animate()">üé¨ Animate</button>
            <button onclick="stopAnimate()" style="background: #f87171;">‚èπ Stop</button>
        </div>

        <div class="status" id="status">Click Animate or adjust controls</div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;

        let animating = false;
        let animationId;
        let time = 0;

        // Vector operations
        const vec3 = {
            add: (a, b) => [a[0] + b[0], a[1] + b[1], a[2] + b[2]],
            sub: (a, b) => [a[0] - b[0], a[1] - b[1], a[2] - b[2]],
            mul: (a, s) => [a[0] * s, a[1] * s, a[2] * s],
            dot: (a, b) => a[0] * b[0] + a[1] * b[1] + a[2] * b[2],
            length: (a) => Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]),
            normalize: (a) => { const l = vec3.length(a); return [a[0] / l, a[1] / l, a[2] / l]; },
            reflect: (d, n) => vec3.sub(d, vec3.mul(n, 2 * vec3.dot(d, n)))
        };

        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16) / 255;
            const g = parseInt(hex.slice(3, 5), 16) / 255;
            const b = parseInt(hex.slice(5, 7), 16) / 255;
            return [r, g, b];
        }

        function intersectSphere(origin, dir, center, radius) {
            const oc = vec3.sub(origin, center);
            const a = vec3.dot(dir, dir);
            const b = 2 * vec3.dot(oc, dir);
            const c = vec3.dot(oc, oc) - radius * radius;
            const d = b * b - 4 * a * c;
            if (d < 0) return null;
            const t = (-b - Math.sqrt(d)) / (2 * a);
            if (t > 0.001) return t;
            return null;
        }

        function render() {
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;

            const color1 = hexToRgb(document.getElementById('sphere1Color').value);
            const color2 = hexToRgb(document.getElementById('sphere2Color').value);
            const lightX = parseFloat(document.getElementById('lightX').value);
            const reflectivity = parseFloat(document.getElementById('reflection').value);

            const sphere1Pos = animating ? [-1.5 + Math.sin(time) * 0.5, 0, 3] : [-1.5, 0, 3];
            const sphere2Pos = animating ? [1.5 + Math.cos(time) * 0.5, -0.5, 4] : [1.5, -0.5, 4];

            const spheres = [
                { center: sphere1Pos, radius: 1, color: color1, reflective: reflectivity },
                { center: sphere2Pos, radius: 1.2, color: color2, reflective: reflectivity },
                { center: [0, 5001, 0], radius: 5000, color: [0.3, 0.3, 0.3], reflective: 0.1 } // Ground
            ];

            const light = [lightX, -2, 0];
            const camera = [0, 0, -5];

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const px = (x - width / 2) / height;
                    const py = (y - height / 2) / height;

                    const dir = vec3.normalize([px, py, 1]);
                    let color = traceRay(camera, dir, spheres, light, 0);

                    const i = (y * width + x) * 4;
                    data[i] = Math.min(255, color[0] * 255);
                    data[i + 1] = Math.min(255, color[1] * 255);
                    data[i + 2] = Math.min(255, color[2] * 255);
                    data[i + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function traceRay(origin, dir, spheres, light, depth) {
            if (depth > 2) return [0.1, 0.1, 0.15]; // Sky color

            let closest = null;
            let minT = Infinity;

            for (const sphere of spheres) {
                const t = intersectSphere(origin, dir, sphere.center, sphere.radius);
                if (t && t < minT) {
                    minT = t;
                    closest = sphere;
                }
            }

            if (!closest) return [0.1, 0.1, 0.15]; // Sky

            const hit = vec3.add(origin, vec3.mul(dir, minT));
            const normal = vec3.normalize(vec3.sub(hit, closest.center));
            const toLight = vec3.normalize(vec3.sub(light, hit));

            // Diffuse lighting
            const diffuse = Math.max(0, vec3.dot(normal, toLight));

            // Shadow check
            let shadow = 1;
            for (const sphere of spheres) {
                if (sphere === closest) continue;
                if (intersectSphere(hit, toLight, sphere.center, sphere.radius)) {
                    shadow = 0.3;
                    break;
                }
            }

            let color = vec3.mul(closest.color, (0.2 + diffuse * 0.8) * shadow);

            // Reflection
            if (closest.reflective > 0) {
                const reflectDir = vec3.reflect(dir, normal);
                const reflectColor = traceRay(hit, reflectDir, spheres, light, depth + 1);
                color = vec3.add(
                    vec3.mul(color, 1 - closest.reflective),
                    vec3.mul(reflectColor, closest.reflective)
                );
            }

            return color;
        }

        function animate() {
            animating = true;
            document.getElementById('status').textContent = 'Animating...';
            function loop() {
                if (!animating) return;
                time += 0.05;
                render();
                animationId = requestAnimationFrame(loop);
            }
            loop();
        }

        function stopAnimate() {
            animating = false;
            cancelAnimationFrame(animationId);
            document.getElementById('status').textContent = 'Animation stopped';
        }

        // Initial render
        render();
    </script>
</body>

</html>