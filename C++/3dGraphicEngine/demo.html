<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Graphics Engine - C++ Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', sans-serif;
            background: #000;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
        }

        h1 {
            color: #f87171;
            margin-bottom: 10px;
        }

        .badge {
            background: linear-gradient(135deg, #f87171, #dc2626);
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.75rem;
            display: inline-block;
            margin-bottom: 15px;
        }

        canvas {
            border: 2px solid #333;
            border-radius: 10px;
        }

        .controls {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .control-group {
            background: rgba(255, 255, 255, 0.05);
            padding: 12px 20px;
            border-radius: 10px;
            text-align: center;
        }

        .control-group label {
            display: block;
            font-size: 0.8rem;
            color: #888;
            margin-bottom: 5px;
        }

        select,
        input[type="range"] {
            background: #222;
            border: 1px solid #444;
            color: #fff;
            padding: 5px 10px;
            border-radius: 5px;
        }

        .info {
            margin-top: 15px;
            color: #888;
            font-size: 0.85rem;
        }
    </style>
</head>

<body>
    <span class="badge">C++ Demo</span>
    <h1>ðŸŽ® 3D Graphics Engine</h1>

    <canvas id="canvas" width="600" height="450"></canvas>

    <div class="controls">
        <div class="control-group">
            <label>Shape</label>
            <select id="shape" onchange="changeShape()">
                <option value="cube">Cube</option>
                <option value="pyramid">Pyramid</option>
                <option value="octahedron">Octahedron</option>
            </select>
        </div>
        <div class="control-group">
            <label>Rotation X</label>
            <input type="range" id="rotX" min="0" max="6.28" step="0.01" value="0">
        </div>
        <div class="control-group">
            <label>Rotation Y</label>
            <input type="range" id="rotY" min="0" max="6.28" step="0.01" value="0">
        </div>
        <div class="control-group">
            <label>Zoom</label>
            <input type="range" id="zoom" min="100" max="400" value="200">
        </div>
    </div>

    <p class="info">Drag on canvas to rotate â€¢ Scroll to zoom</p>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;

        let rotX = 0, rotY = 0, rotZ = 0;
        let zoom = 200;
        let autoRotate = true;
        let dragging = false;
        let lastMouse = { x: 0, y: 0 };

        const shapes = {
            cube: {
                vertices: [
                    [-1, -1, -1], [1, -1, -1], [1, 1, -1], [-1, 1, -1],
                    [-1, -1, 1], [1, -1, 1], [1, 1, 1], [-1, 1, 1]
                ],
                edges: [
                    [0, 1], [1, 2], [2, 3], [3, 0], // back
                    [4, 5], [5, 6], [6, 7], [7, 4], // front
                    [0, 4], [1, 5], [2, 6], [3, 7]  // connecting
                ],
                faces: [
                    [0, 1, 2, 3], [4, 5, 6, 7], [0, 1, 5, 4], [2, 3, 7, 6], [0, 3, 7, 4], [1, 2, 6, 5]
                ]
            },
            pyramid: {
                vertices: [
                    [0, 1, 0],   // top
                    [-1, -1, -1], [1, -1, -1], [1, -1, 1], [-1, -1, 1]  // base
                ],
                edges: [
                    [0, 1], [0, 2], [0, 3], [0, 4], // top to base
                    [1, 2], [2, 3], [3, 4], [4, 1]  // base
                ],
                faces: [
                    [1, 2, 3, 4], [0, 1, 2], [0, 2, 3], [0, 3, 4], [0, 4, 1]
                ]
            },
            octahedron: {
                vertices: [
                    [0, 1, 0], [0, -1, 0],  // top, bottom
                    [1, 0, 0], [-1, 0, 0], [0, 0, 1], [0, 0, -1]  // middle
                ],
                edges: [
                    [0, 2], [0, 3], [0, 4], [0, 5],
                    [1, 2], [1, 3], [1, 4], [1, 5],
                    [2, 4], [4, 3], [3, 5], [5, 2]
                ],
                faces: [
                    [0, 2, 4], [0, 4, 3], [0, 3, 5], [0, 5, 2],
                    [1, 2, 4], [1, 4, 3], [1, 3, 5], [1, 5, 2]
                ]
            }
        };

        let currentShape = shapes.cube;

        function rotateX(v, a) {
            const c = Math.cos(a), s = Math.sin(a);
            return [v[0], v[1] * c - v[2] * s, v[1] * s + v[2] * c];
        }

        function rotateY(v, a) {
            const c = Math.cos(a), s = Math.sin(a);
            return [v[0] * c + v[2] * s, v[1], -v[0] * s + v[2] * c];
        }

        function rotateZ(v, a) {
            const c = Math.cos(a), s = Math.sin(a);
            return [v[0] * c - v[1] * s, v[0] * s + v[1] * c, v[2]];
        }

        function project(v) {
            const z = v[2] + 5;
            const scale = zoom / z;
            return [width / 2 + v[0] * scale, height / 2 - v[1] * scale, z];
        }

        function render() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);

            // Draw grid
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 20; i++) {
                ctx.beginPath();
                ctx.moveTo(i * 30, 0);
                ctx.lineTo(i * 30, height);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i * 30);
                ctx.lineTo(width, i * 30);
                ctx.stroke();
            }

            // Transform vertices
            const transformed = currentShape.vertices.map(v => {
                let t = rotateX(v, rotX);
                t = rotateY(t, rotY);
                t = rotateZ(t, rotZ);
                return project(t);
            });

            // Sort faces by depth (painter's algorithm)
            const facesWithDepth = currentShape.faces.map((face, i) => {
                const avgZ = face.reduce((sum, vi) => sum + transformed[vi][2], 0) / face.length;
                return { face, depth: avgZ, index: i };
            }).sort((a, b) => b.depth - a.depth);

            // Draw faces
            const colors = ['#f87171', '#10b981', '#fbbf24', '#a855f7', '#38bdf8', '#f472b6'];
            facesWithDepth.forEach(({ face, index }) => {
                ctx.beginPath();
                ctx.moveTo(transformed[face[0]][0], transformed[face[0]][1]);
                for (let i = 1; i < face.length; i++) {
                    ctx.lineTo(transformed[face[i]][0], transformed[face[i]][1]);
                }
                ctx.closePath();
                ctx.fillStyle = colors[index % colors.length] + '80';
                ctx.fill();
                ctx.strokeStyle = colors[index % colors.length];
                ctx.lineWidth = 2;
                ctx.stroke();
            });

            // Draw vertices
            transformed.forEach(v => {
                ctx.beginPath();
                ctx.arc(v[0], v[1], 4, 0, Math.PI * 2);
                ctx.fillStyle = '#fff';
                ctx.fill();
            });

            // Info text
            ctx.fillStyle = '#10b981';
            ctx.font = '14px Consolas';
            ctx.fillText(`Rotation: X=${rotX.toFixed(2)} Y=${rotY.toFixed(2)}`, 10, 25);
            ctx.fillText(`Vertices: ${currentShape.vertices.length} | Edges: ${currentShape.edges.length}`, 10, 45);
        }

        function animate() {
            if (autoRotate && !dragging) {
                rotY += 0.02;
                rotX += 0.01;
            }

            rotX = parseFloat(document.getElementById('rotX').value) || rotX;
            rotY = parseFloat(document.getElementById('rotY').value) || rotY;
            zoom = parseFloat(document.getElementById('zoom').value);

            render();
            requestAnimationFrame(animate);
        }

        function changeShape() {
            currentShape = shapes[document.getElementById('shape').value];
        }

        // Mouse controls
        canvas.addEventListener('mousedown', e => {
            dragging = true;
            autoRotate = false;
            lastMouse = { x: e.offsetX, y: e.offsetY };
        });

        canvas.addEventListener('mousemove', e => {
            if (dragging) {
                const dx = e.offsetX - lastMouse.x;
                const dy = e.offsetY - lastMouse.y;
                rotY += dx * 0.01;
                rotX += dy * 0.01;
                document.getElementById('rotX').value = rotX % 6.28;
                document.getElementById('rotY').value = rotY % 6.28;
                lastMouse = { x: e.offsetX, y: e.offsetY };
            }
        });

        canvas.addEventListener('mouseup', () => dragging = false);
        canvas.addEventListener('mouseleave', () => dragging = false);

        canvas.addEventListener('wheel', e => {
            e.preventDefault();
            zoom = Math.max(100, Math.min(400, zoom - e.deltaY * 0.5));
            document.getElementById('zoom').value = zoom;
        });

        animate();
    </script>
</body>

</html>